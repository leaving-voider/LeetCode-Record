###############################################################################################
# 该题较难，难理解的地方是状态转移，需要区别当所要修改的数为组内的数与组外的数两种情况，以此减少时间复杂度
# 以及该题的破解前提是：我们最后得到的数组得是以k为周期的数组
###########
# 时间复杂度：O(2^C*k+n)，n 是数组 nums 的长度，C 是数组 nums 中元素二进制表示的最大位数，在本题中C=10，哈希表构造时间忽略不计（相比于动规太小了）
# 空间复杂度：O(2^C+n/k)，两个长度为2^C的动规数组，每一个组对应的哈希表的大小为 n/k
###############################################################################################
class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        # x 的范围为 [0, 2^10)
        MAXX = 2**10

        # 动规数组，表示某一组在异或和为某数值的情况下，这些组总计最少需要修改的元素个数（前面的组已经被处理为前提）
        f = [float("inf")] * MAXX
        # 边界条件 f(-1,0)=0
        f[0] = 0
        
        for i in range(k):
            # 第 i 个组的哈希映射
            count = Counter()
            size = 0 # 第i个组元素数量
            for j in range(i, len(nums), k):
                count[nums[j]] += 1
                size += 1

            # 求出第i-1个组的所有状态最小值
            t2min = min(f)

            # 第二个动规数组，存储第i个组的状态
            # t2min对应当x不在该组里时的状态
            g = [t2min] * MAXX
            for mask in range(MAXX): # 枚举所有状态
                for x, countx in count.items(): # 仅需要枚举组内已有的所有数，即x在组里求出的状态，这样才会更小
                    g[mask] = min(g[mask], f[mask ^ x] - countx)
            
            # 更新f动规数组
            f = [val + size for val in g]

        return f[0]