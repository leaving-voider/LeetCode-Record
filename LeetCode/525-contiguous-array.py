###############################################################################################
# 本题本身不难，之前做过类似的【前缀和+哈希】就能解决，但需要有注意的点
# 1、 按常规的遍历会直接超时，应该转化题目为【和为0的最长连续子数组】，则能使用哈希来解决，降低时间复杂度
###########
# 时间复杂度：O(n)，n 是数组 nums 的长度
# 空间复杂度：O(n)，主要消耗为哈希表，哈希表存储的不同和值不会超过n个
###############################################################################################
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        # 转化题目后，sum_表示前i个的和（为1则+1，为0则-1即可）
        sum_, len_, counter = 0, 0, {0:-1} # 同样为了当sum_ == k的情况，k在此题为0

        for i, num in enumerate(nums):
            sum_ += 1 if num == 1 else -1
            if sum_ in counter:
                len_ = max(i - counter[sum_], len_)
            else:
                counter[sum_] = i # 记录最早的就可以了
        return len_

###############################################################################################
# 自己写的，超出时间限制，主要是遍历了所有比当前记录最长更长的可能
# 利用官方给的思路：等价转换题目；因为只需要0的数等于1的数，那么将0换成-1，就可变成【和为0的最长连续子数组】
###############################################################################################
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        sum0 = 0
        sum1 = 0
        total = [] # total[i][0]表示第i个位置前(包括i)0的个数
        len_ = 0
        for i, num in enumerate(nums):
            if num == 0:
                sum0 += 1
            else:
                sum1 += 1
            if sum0 == sum1: # 肯定是当前最大
                len_ = i + 1
            else:
                for j in range(i-len_): # 遍历一次，找可能比当前最长更长的
                    if sum0 - total[j][0] == sum1 - total[j][1]:
                        len_ = max(len_, i-j)
            total.append([sum0, sum1])
        return len_