###############################################################################################
# 题目较难，直接看了官方答案，官方采用动态规划的方法，以空间换时间，学习后给出完整注释
###########
# 时间复杂度：O(m*n²*target)，共四个循环，导致了主要的时间复杂度
# 空间复杂度：O(m*n*target)，即三维动态规划所需要的空间（里面包含状态数量）
###############################################################################################
class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        # 颜色从0开始编号，-1表示未涂色
        houses = [c-1 for c in houses]
        # 三维动态规划, [房子，其颜色，其所属街区]，均从0开始编号
        # 房子 0~m-1 颜色 0~n-1 所属街区 0~target-1
        dp = [[[float("inf")]*target for _ in range(n)] for _ in range(m)] # shape (m, n, target)

        for i in range(m): # 每间房子
            for j in range(n): # 每种颜色
                # 已涂过颜色，而又不是j所指颜色，则这种情况不可能达到，cost默认最大，直接略过即可
                if houses[i] != -1 and houses[i] != j:
                    continue
                
                for k in range(target): # 所属target
                    # 假设上一间房子的颜色为j0，因为上一层可以是任何颜色，所以要遍历所有情况
                    for j0 in range(n):
                        # 颜色相同，属于同一个街区
                        if j == j0:
                            # 考虑第一次的特殊情况，此时先默认赋值为0，后面仅需统一考虑cost即可
                            if i == 0:
                                if k == 0: # 第0个房子的所属街区不可能大于0（从0编号）
                                    dp[i][j][k] = 0
                            else:
                                dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][k])
                        elif i != 0 and k != 0: # 颜色不同，属于不同街区，且不可能是特殊情况（因此默认无限大）
                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j0][k-1])
                    
                    # 房子需要涂漆，因此要加钱，而仅在此种情况的cost非无限大时进行加，否则没有意义
                    if houses[i] == -1 and dp[i][j][k] != float("inf"):
                        dp[i][j][k] += cost[i][j]
        
        # 最后答案就在当房子为第m-1个，颜色遍历所有情况，所属街区为第target-1个
        res = min(dp[m-1][j][target-1] for j in range(n))
        # 最后判断是否是无限大，若是，则此种情况不可达，返回-1
        return -1 if res == float("inf") else res

###############################################################################################
# 基于动态规划的基本方案，官方给出优化版本，即利用无后效性（未来状态仅由当前状态所影响）
# 具体地是：状态dp(i,j,k) 只会从 dp(i−1,⋯,⋯) 转移而来，因此引入滚动数组，优化空间复杂度
# 此外还能将j0所在循环通过替代方案进行删除，优化时间复杂度，但这两种暂时先不做了
###############################################################################################