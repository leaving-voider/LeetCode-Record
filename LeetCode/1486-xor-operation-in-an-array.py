###############################################################################################
# 直接顺次异或即可
###########
# 时间复杂度：O(n)，n个数字
# 空间复杂度：O(1)，常量级别的辅助空间
###############################################################################################
class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        res = 0
        for i in range(n):
            res ^= (start + 2*i)
        return res

###############################################################################################
# 官方给的数学方法，利用异或性质，经过一系列变换后，将时间复杂度降为O(1)
###########
# 时间复杂度：O(1)，常数时间便能求解
# 空间复杂度：O(1)，常量级别的辅助空间
###############################################################################################
class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        def sumXor(x):
            if x%4 == 0:
                return x
            elif x%4 == 1:
                return 1
            elif x%4 == 2:
                return x+1
            return 0
        s = start >> 1
        e = n & start & 1
        res = sumXor(s-1) ^ sumXor(s+n-1)
        return (res << 1) | e